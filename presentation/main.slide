Go研修の感想&Go言語のスタック伸長
6 Dec 2019

kurenaif

* whoami

- kurenaif
- 全てにおいてこのアイコンの人
- 好き: Rust, C++11, C++14, C++17, C++20, Swift(がiOSアプリわからん)
- 仕事: モバイルセキュリティ
- 趣味: Cryptography, 競技プログラミング, テトリス

.image images/icon_mini.png 256 256

* なぜGo研修?

- Go言語いいよ！といろんなひとに布教される(大学時代)
- かんたんだよ！ すぐ入門できるよ！と言われる(大学時代)
- すぐ入門できるんだったら後でいいよなぁ(大学時代)
- そろそろgo言語さわるか(社会人)
- Go研修を受けよう(社会人)

* Go研修の感想

- constや型による強い成約が難しい。
- ジェネリクスがないので、抽象化の難易度が高い

→ 過度な抽象化や不要な成約によるオーバーテクノロジーを事前に防げるのはいい

* Go研修の感想

- ftpサーバーの簡単な仕組みを勉強するきっかけになれてよかった。
- 数値計算やWebなど、様々な読まれ方などを想定しており、よかった。
- 自分のエラーハンドリングの雑さが顕在化してしまったので、今後覚えていきたいと思った。

* 本日のトピック

Go言語のstack伸長について

* Go言語のstack伸長 (プログラミング言語 Go p.323)

- Goルーチンのスタックは2KBから始まり、必要があれば伸長する
- それによるパフォーマンス影響は？
- スタックオーバーフローは起きにくくなるの？

* C言語の関数呼び出し

- 特にソースコードそのものには意味はありません。(最適化&inline化封じ)

.code src/c_function/a.c

* C言語の関数呼び出し(x64環境)

    <f>:
        push   rbp
        mov    rbp,rsp
        sub    rsp,0x1c0 ; スタック領域確保
        (中略)
        leave  
        ret    

    <main>:
        (略)
        mov    esi,0x2 ; x64環境では、スタックに積まずにレジスタに入れる
        mov    edi,0x1
        call   1145 <f> ; f(1,2)を意味する
        (略)

* Go言語の関数呼び出し

.code src/go_function/a.go

* Go言語の関数呼び出し

- leaveとかpopとか使ってなくて、自分でadd命令を発行している
- 関数呼び出し時にスタック領域の確認をしている

    <main.f>:
        mov    rcx,QWORD PTR fs:0xfffffffffffffff8
        lea    rax,[rsp-0x2b8]
        cmp    rax,QWORD PTR [rcx+0x10] ; スタック伸長すべきか比較
        jbe    48cf75 <main.f+0xd5> ; スタック伸長をcallするところにジャンプ
        sub    rsp,0x338 ; スタック領域確保
        (中略)
        add    rsp,0x338 ; スタック領域を解放
        ret    

        48cf75: call   4517a0 <runtime.morestack_noctxt>
        48cf7a: jmp    48cea0 <main.f> 関数を呼び直す

    <main.main>:
        sub    rsp,0x58
        mov    QWORD PTR [rsp+0x50],rbp
        lea    rbp,[rsp+0x50]
        mov    QWORD PTR [rsp],0x1
        mov    QWORD PTR [rsp+0x8],0x2
        call   48cea0 <main.f>

* 実験 メモ化フィボナッチ数列の比較

* C++による実装

.code src/c_fibo/a.cpp /^int fibo/,/^}/ 

.code src/c_fibo/a.cpp /^int main/,/^}/ 

* Goによる実装

.code src/go_fibo/a.go /^func fibo/,/^}/ 

.code src/go_fibo/a.go /^func main/,/^}/ 

* スタック伸長の実験(スタックにたくさん積んでも実行できるか)

- 1000000番目のフィボナッチ数列(MOD 10^9+7)
- go言語は `ulmit` にかかわらず、呼び出しに成功していることがわかる。

    $ ulimit -s
        8192
    $ ./a 1000000 # go実装
        918091266
    $ ./a.out 1000000 # C++実装
        Segmentation fault (core dumped)
    $ ulimit -s 81920 # スタック伸長
    $ ./a.out 1000000 # C++実装
        918091266


* 実行時間比較

- Go言語のほうが5倍くらい遅い

    $ time ./a 1000000 # go実装
    918091266

    real	0m0.133s
    user	0m0.119s
    sys	0m0.016s

    $ time ./a.out 1000000 # C++実装
    918091266

    real	0m0.028s
    user	0m0.012s
    sys	0m0.016s

* スタック伸長にかかる時間の計測

- 一度確保したスタック領域はわざわざ縮小させないはず
- 2回フィボナッチ数列を実行し、実行時間の差を見る

.code src/go_fibo_double/a.go /^func main/,/^}/ 

* スタック伸長にかかる時間の計測

- 一度確保したスタック領域はわざわざ縮小させないはず
- 2回フィボナッチ数列を実行し、実行時間の差を見る

- 60msecくらいstack伸長に時間が取られていたらしい
- でもまだ倍くらい遅い
- C++実装側も.at()を使ってアクセスしているので、配列外参照チェックではないはず
- スタック領域の確認で持ってかれてる…?
- 今回ヒープのオブジェクトを使っているわけではないからGCは関係ないはず…

    ./a 1000000                                                                                                                                           18:57:12
    918091266
    127.140386ms
    918091266
    67.541237ms

* まとめ

- フィボナッチ数列を求める関数をメモ化再帰で実装して、C++とgoで実装した
- スタック伸長で60msecくらい持ってかれたけど二回目はそんなにだった
- 言語やコンパイラごとに得意な処理や苦手な処理があるので、今後も詰めていきたい
- アセンブラ ウラギラナイ

* おまけ

- フィボナッチ数列は行列の繰り返し二乗法でO(log(N))で実装できるよ
